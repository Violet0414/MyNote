#### Vue2和Vue3的区别

​	从个人开发层面来说，我认为Vue3和Vue2最大的区别就是新增了组合式api，解决了Vue2混入的弊端，可以自定义hook，同时Vue3对ts有着更好的支持性。从框架的优化层面来说，其优化了diff算法，打包前也新增了Tree shaking机制，优化了打包体积。



#### Vue2和Vue3 diff算法的区别

1. **虚拟 DOM**：
   - Vue 3 的虚拟 DOM 实现更高效，采用了 Proxy API，以减少对响应式系统的开销。
2. **树形结构**：
   - Vue 3 引入了基于组件的树形结构，优化了 diff 过程。它支持更细粒度的更新，减少了不必要的比较。
3. **Fragment 支持**：
   - Vue 3 允许组件返回多个根节点（Fragments），这简化了结构，减少了多余的包裹元素。
4. **静态节点的提升**：
   - Vue 3 更加智能地提升静态节点，只在必要时进行更新，提高了性能。
5. **性能优化**：
   - Vue 3 通过使用更好的优化策略，降低了比较的复杂度，使得在大规模应用中的性能提升更为明显。

这些改进使得 Vue 3 的 diff 算法在性能和可维护性上都更为优越。



#### ref和reactive

​	两者都用于声明响应式数据，并且ref底层仍然是使用reactive实现，简单来说reactive能做的ref都能做。ref一般用于声明基本数据，reactive一般用于声明复杂数据，例如层级较深的对象或数组，但官方推荐使用ref进行声明响应式数据，以避免在特殊情况下响应式的丢失。



#### Vue2和Vue3如何实现响应式

​	在Vue2中变量在data()函数内进行声明作统一管理，而在Vue3中使用**ref()**可随时进行响应式变量的声明，就导致声明的响应式数据可能不再是一个对象。

​	**Vue2数据代理：**

​		通过**Object.defineProperty()**实现，该方法会在对象上定义一个新属性，或者修改一个对象的现有属性，之后返回此对象，以此实现数据的响应式。

​	**Vue3数据代理：**

​		通过**Proxy**对象进行数据代理，该对象用于创建一个对象代理，从而实现对数据基本操作的拦截和自定义（如查找，赋值，枚举，函数调用）。

​	由此可以看出，**Proxy代理方式本质仍是对象服务**，但在Vue3中使用该方式也不能进行普通数据的代理，所以在调用ref()时在创建Proxy对象的同时，在其对象上添加了一个value属性，该属性值则是定义的内容。**在其值改变时则是通过监听Proxy的数据劫持来进行响应式数据处理**，而在模板中使用时Vue则会默认调用对应的.value属性，从而完成对数据的操作使用。



