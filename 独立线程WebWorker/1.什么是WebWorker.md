#### 前言

​	众所周知，js最初设计是运行在浏览器中的，为了防止多个线程同时操作DOM，带来渲染冲突问题，所以js执行器被设计成单线程。但随着前端技术的发展，js能力远不止如此，**当我们遇到需要大量计算的场景时（比如图像处理、视频解码等），js线程往往会被长时间阻塞，甚至造成页面卡顿，影响用户体验。为了解决单线程带来的这一弊端，Web Worker 应运而生。**



#### Web Worker是什么

​	Web Worker是 HTML5 标准的一部分，这一规范定义了一套 API，允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者**利用 js 操作多线程的能力**。

​	**由于其是独立线程，Worker 线程与 js 主线程能够同时运行，互不阻塞**。所以，在我们有大量运算任务时，可以把运算任务交给 Worker 线程去处理，当 Worker 线程计算完成，再把结果返回给 js 主线程。这样，js 主线程只用专注处理业务逻辑，不用耗费过多时间去处理大量复杂计算，从而减少了阻塞时间，也提高了运行效率，页面流畅度和用户体验自然而然也提高了。



#### Web Worker能干什么

​	Web Worker虽然是在浏览器环境唤起，但**它与当前页面窗口运行在不同的全局上下文中**，我们**常用的顶层对象window以及parent对象在Worker线程上下文中是不可用的**。另外，在该线程上下文中，**操作DOM的行为也是不可行的，document对象也不存在**。但是location和navigator对象可以通过读取方式访问。

​	除此之外，**绝大多数 Window 对象上的方法和属性，都被共享到 Worker 上下文全局对象 [WorkerGlobalScope](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWorkerGlobalScope) 中。同样，Worker 线程上下文也存在一个顶级对象 self**。



