### Web Worker的使用

#### **1.创建worker**

​	创建worker只需要通过new调用Worker()构造函数即可。

```js
const worker = new Worker(path, options);
```

| 参数                | 说明                                                         |
| :------------------ | ------------------------------------------------------------ |
| path                | 有效的js脚本的地址，必须遵守同源策略。无效的js地址或者违反同源策略，会抛出`SECURITY_ERR `类型错误 |
| options.type        | 可选，用以指定 worker 类型。该值可以是 `classic` 或 `module`。 如未指定，将使用默认值 `classic` |
| options.credentials | 可选，用以指定 worker 凭证。该值可以是 `omit`, `same-origin`，或 `include`。如果未指定，或者 type 是 `classic`，将使用默认值 `omit` (不要求凭证) |
| options.name        | 可选，在 [`DedicatedWorkerGlobalScope`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDedicatedWorkerGlobalScope) 的情况下，用来表示 worker 的 scope 的一个 [`DOMString`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2Fconflicting%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FString_6fa58bba0570d663099f0ae7ae8883ab) 值，主要用于调试目的。 |

---

#### **2. js 主线程与 worker 线程数据传递**

主线程与 worker 线程都是通过 `postMessage` 方法来发送消息，以及监听 `message` 事件来接收消息。

```js
// main.js（主线程）
const myWorker = new Worker('/worker.js'); // 创建worker

myWorker.addEventListener('message', e => { // 接收消息
    console.log(e.data); // Greeting from Worker.js，worker线程发送的消息
});

// 这种写法也可以
// myWorker.onmessage = e => { // 接收消息
//    console.log(e.data);
// };

myWorker.postMessage('Greeting from Main.js'); // 向 worker 线程发送消息，对应 worker 线程中的 e.data

```

```js
// worker.js（worker线程）
self.addEventListener('message', e => { // 接收到消息
    console.log(e.data); // Greeting from Main.js，主线程发送的消息
    self.postMessage('Greeting from Worker.js'); // 向主线程发送消息
});

```

一个简单 worker 线程就创建成功了。

`postMessage()` 方法接收的参数可以是字符串、对象、数组等。具体我们在#2.7讨论。

主线程与 worker 线程之间的数据传递是传值而不是传地址。所以你会发现，即使你传递的是一个`Object`，并且被直接传递回来，接收到的也不是原来的那个值了。

```js
// main.js（主线程）
const myWorker = new Worker('/worker.js');
const obj = {name: '小明'};
myWorker.addEventListener('message', e => { 
    console.log(e.data === obj); // false
});
myWorker.postMessage(obj);
```

```js
// worker.js（worker线程）
self.addEventListener('message', e => {
    self.postMessage(e.data); // 将接收到的数据直接返回
});
```

---

#### **3.监听错误信息**

web worker 提供两个事件监听错误，`error` 和 `messageerror`。这两个事件的区别是:

| 事件           | 描述                                              |
| -------------- | ------------------------------------------------- |
| `error`        | 当worker内部出现错误时触发                        |
| `messageerror` | 当 `message` 事件接收到无法被反序列化的参数时触发 |

监听方式跟接收消息一致：

```js
// main.js（主线程）
const myWorker = new Worker('/worker.js'); // 创建worker

myWorker.addEventListener('error', err => {
    console.log(err.message);
});
myWorker.addEventListener('messageerror', err => {
    console.log(err.message)
});

```

---

#### **4.关闭worker线程**

```js
// main.js（主线程）
const myWorker = new Worker('/worker.js'); // 创建worker
myWorker.terminate(); // 关闭worker
```

```js
// worker.js（worker线程）
self.close(); // 直接执行close方法就ok了
```

​	**无论是在主线程关闭 worker，还是在 worker 线程内部关闭 worker，worker 线程当前的 Event Loop 中的任务会继续执行。**至于 worker 线程下一个 Event Loop 中的任务，则会被直接忽略，不会继续执行。

​	区别是，**在主线程手动关闭 worker，主线程与 worker 线程之间的连接都会被立刻停止，即使 worker 线程当前的 Event Loop 中仍有待执行的任务继续调用 `postMessage()` 方法，但主线程不会再接收到消息。**

​	**在 worker 线程内部关闭 worker**，不会直接断开与主线程的连接，而是等 worker 线程当前的 Event Loop 所有任务执行完，再关闭。也就是说，**在当前 Event Loop 中继续调用 `postMessage()` 方法，主线程还是能通过监听`message`事件收到消息的**。



**在主线程关闭worker：**

- worker 线程在接受到消息后，立即向主线程回复一条消息。然后利用计时器添加一个宏任务；利用 Promise 添加一个微任务；执行一个 for 循环。目的都是向主线程回复一条消息。

- 主线程在接收到消息后立即关闭 worker 线程。

  ```js
  // main.js（主线程）
  const myWorker = new Worker('/worker.js'); // 创建 worker
  
  myWorker.addEventListener('message', e => {
      console.log(e.data);
      myWorker.terminate(); // 关闭 worker
  });
  
  myWorker.postMessage('Greeting from Main.js');
  ```

  ```js
  // worker.js（worker线程）
  self.addEventListener('message', e => {
  
      postMessage('Greeting from Worker');
      
      setTimeout(() => {
        console.log('setTimeout run');
        postMessage('Greeting from SetTimeout');
      });
      
      Promise.resolve().then(() => {
        console.log('Promise run');
        postMessage('Greeting from Promise');
      })
      
      for (let i = 0; i < 1001; i++) {
        if (i === 1000) {
          console.log('Loop run');
          postMessage('Greeting from Loop');
        }
      }
  });
  ```

  **运行结果如下：**
  
  ![](F:\MyNote\笔记图片\关闭web worker线程运行机制.jpg)
  
  **1.主线程只会接收到 worker 线程第一次通过 `postMessage()` 发送的消息，后面的消息不会接收到；**
  
  **2.worker 线程当前 Event Loop 里的任务会继续执行，包括微任务；**
  
  **3.worker 线程里 setTimeout 创建的下一个 Event Loop 任务队列没有执行。**
  
  ---

**在 worker 线程内部关闭 worker**

```js
// main.js（主线程）
const myWorker = new Worker('/worker.js'); // 创建 worker

myWorker.addEventListener('message', e => {
    console.log(e.data);
});

myWorker.postMessage('Greeting from Main.js');
```

```js
// worker.js（worker线程）
self.addEventListener('message', e => {

    postMessage('Greeting from Worker');
    
    self.close(); // 关闭 worker
    
    setTimeout(() => {
        console.log('setTimeout run');
        postMessage('Greeting from SetTimeout');
    });
    
    Promise.resolve().then(() => {
        console.log('Promise run');
        postMessage('Greeting from Promise');
    })
    
    for (let i = 0; i < 1001; i++) {
        if (i === 1000) {
            console.log('Loop run');
            postMessage('Greeting from Loop');
        }
    }
    
});
```

![](F:\MyNote\笔记图片\worker线程内部关闭.jpg)

**与在主线程关闭不同的是，worker 线程当前的 Event Loop 任务队列中的 `postMessage()` 事件都会被主线程监听到**

