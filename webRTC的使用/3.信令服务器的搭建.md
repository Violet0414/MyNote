#### 信令服务器的搭建

​	信令服务器实际上就相当于手机拨打电话这个流程中的运营商，运营商负责替我们中转、接听、挂断等等操作。在这里，**运营商的服务器就是信令服务器**。信令服务器在不做复杂操作时，就是个即时通讯服务器，转发通话双方需要交换的信息，因此我们可以直接写个**WebSocket服务端**来完成信令服务器的使命。

​	搭建服务器之前，我们需要明确服务端需要具备哪些功能，当下我们需要针对WebRTC会话过程中需要转发的逻辑去搭建服务器。

![](F:\MyNote\笔记图片\WebRTC服务端需具备的功能.png)



​	为完成以上服务器构思，可以尝试写出一个最基本的信令服务器，而最终目的是搭建一个会议系统，所以设计的东西需满足一个会议的基本条件。**即拥有用户的单独标识（userId）和集体标识（roomId）**，并在会议室中如何使用这些用户信息。以下将使用Redis的Hash进行数据的存储。

![](F:\MyNote\笔记图片\Redis存储会议标识.png)

​	信令服务器的搭建以下将使用nodejs书写。

```js
        const httpServer = require('http').createServer();
        const io = require('socket.io')(httpServer);

        //redis
        var redis = require('redis')
        const roomKey = "meeting-room::"
        var redisClient = redis.createClient(6379, '127.0.0.1')
        redisClient.on('error', function (err) {
          console.log('redisClient connect Error ' ,err);
        });

        const userMap = new Map() // user - > socket
        io.on('connection', async (socket) => {
            await onListener(socket)
        });

        httpServer.listen(18080, async() => {
          console.log('服务器启动成功 *:18080');
          await redisClient.connect();
        });

        /**
         * res data
         */
        function getMsg(type,msg,status=200,data=null){
            return {"type":type,"msg":msg,"status":status,"data":data}
        }

        function getParams(url,queryName){
            let query = decodeURI(url.split('?')[1]);
            let vars = query.split("&");
            for (var i = 0; i < vars.length; i++) {
              var pair = vars[i].split("=");
              if (pair[0] === queryName) {
                return pair[1];
              }
            }
            return null;
        }

        /**
         * DB data
         * @author suke
         * @param {Object} userId
         * @param {Object} roomId
         */
        async function getUserDetailByUid(userId,roomId){
            let res = JSON.stringify(({"userId":userId,"roomId":roomId}))
            console.log(res)
            return res
        }

        /**
         * 监听
         * @author suke
         * @param {Object} s
         */
        async function onListener(s){
            let url = s.client.request.url
            let userId = getParams(url,'userId')
            let roomId = getParams(url,'roomId')
            console.log("client uid："+userId+" roomId: "+roomId+" online ")
            //user map
            userMap.set(userId,s)
            //room cache
            if(roomId){
                await redisClient.hSet(roomKey+roomId,userId, await getUserDetailByUid(userId,roomId))
                oneToRoomMany(roomId,getMsg('join',userId+ ' join then room'))
            }

            s.on('msg', async (data) => {
                  console.log("msg",data)
                  await oneToRoomMany(roomId,data)
            });

            s.on('disconnect', () => { 
                  console.log("client uid："+userId+" roomId: "+roomId+" offline ")
                  userMap.delete(userId)
                  if(roomId){
                      redisClient.hDel(roomKey+roomId,userId)
                      oneToRoomMany(roomId,getMsg('leave',userId+' leave the room '))
                  }
            });    

            s.on('roomUserList', async (data) => {
                // console.log("roomUserList msg",data)
                s.emit('roomUserList',await getRoomUser(data['roomId']))
            })
            s.on('call',(data) => {
                let targetUid = data['targetUid']
                if(userMap.get(targetUid)){
                    oneToOne(targetUid,getMsg('call',"远程呼叫",200,data))
                }else{
                    console.log(targetUid+ "不在线")
                }
            })
            s.on('candidate',(data) => {
                let targetUid = data['targetUid']
                if(userMap.get(targetUid)){
                    oneToOne(targetUid,getMsg('candidate',"ice candidate",200,data))
                }else{
                    console.log(targetUid+ "不在线")
                }
            })
            s.on('offer',(data) => {
                let targetUid = data['targetUid']
                if(userMap.get(targetUid)){
                    oneToOne(targetUid,getMsg('offer',"rtc offer",200,data))
                }else{
                    console.log(targetUid+ "不在线")
                }
            })
            s.on('answer',(data) => {
                let targetUid = data['targetUid']
                if(userMap.get(targetUid)){
                    oneToOne(targetUid,getMsg('answer',"rtc answer",200,data))
                }else{
                    console.log(targetUid+ "不在线")
                }
            })
        }

        /**
         * ono to one (event msg)
         * @author suke
         * @param {Object} uid
         * @param {Object} msg
         */
        function oneToOne(uid,msg){
            let s = userMap.get(uid)
            if(s){
                s.emit('msg',msg)
            }else{
                console.log(uid+"用户不在线")
            }
        }

        /**
         * 获取房间用户列表
         * @author suke
         * @param {Object} roomId
         */
        async function getRoomUser(roomId){
            return await redisClient.hGetAll(roomKey+roomId)
        }

        /**
         * one to room many
         * @author suke
         * @param {Object} roomId
         * @param {Object} msg
         */
        async function oneToRoomMany(roomId,msg){
            let ulist = await redisClient.hGetAll(roomKey+roomId)
            for(const uid in ulist){
              oneToOne(uid,msg)
            }

        }

```



#### 扩展

​	在以上WebRTC会话流程中，并未出现媒体信息的交换，所以很明显，WebRTC不单单可用于音视频通话。

​	在无需视频通话的情况下，我们**仍可以使用WebRTC这个桥梁进行一些数据的双向传输**，现阶段已经有一些网站使用该方式上传用户数据或其他消息媒介，而且由于**WebRTC中数据的传输协议并非HTTP或者WebSocket协议请求**，很多探测工具也无法察觉到。