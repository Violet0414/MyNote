#### 基础构思

​	在开始之前，我们先熟悉下这个最简单的讲课场景，首先看下图模拟场景，T 作为老师，需要将自己的画面实时地发送给下面的三个学生，但是学生却不需要将自己的画面同步给老师，而仅仅是在需要反馈的时候给予老师反馈即可。**场景实际则为一个小型直播。**

![](F:\MyNote\笔记图片\私有化会议直播流程图.png)



​	webRTC实现点对点通信本质上都是建立对应的连接，然后将用户信息存储至本地，通过其存储的信令来进行点对点通信，那么一对多的通话只需要在建立彼此建立连接后，将关联关系都保存至本地即可。

​	在之前我们提起建立通话的核心是**PeerConnection**对象，任何建立视频通话的双方都离不开该对象，其对象内包含了关联关系的核心协商数据。所以一对多的场景下，只需分别与对象建立联系，维护各自独立的**PeerConnection**对象即可。

![](F:\MyNote\笔记图片\webRTC一对多建立联系.png)



​	如上图所示，老师端只需要分别保存一份对应学生的**PeerConnection**对象，学生端只需保存自己和老师之间的关联信息，即一份核心对象即可。



**老师端**

```js
// T：9999 S-1：10001 S-2：10002 S-3:10003 分别代表上面流程图中的师生
var RtcPcMaps = new Map()
const TS01= 9999 -10001
const TS02= 9999 -10002
const TS03= 9999 -10003
RtcPcMaps.set(TS01, new PeerConnection()) //维护T-S-1关系
RtcPcMaps.set(TS01, new PeerConnection()) //维护T-S-2关系
RtcPcMaps.set(TS01, new PeerConnection()) //维护T-S-3关系 
```

在老师 T 收到学生 S 需要关联的“意向”后，创建三个`PeerConnection`核心对象，去维护三分关系，然后将其保存在本地的集合中。



**学生端**

```js
// SXXT为当前具体是哪个学生，每个学生只需维护自身和老师的关联
var RtcPcMaps = new Map()
const S01T = 10001-9999 
RtcPcMaps.set(S01T, new PeerConnection()) // 学生维护和老师的关联
```

​	可以很清晰地看到，在学生端只需要维护一份和老师的关系即可，在建立关联之后，将老师的直播流拉取，然后在本地展示。而老师端相对复杂些，需要维护 3 份关系，如果学生有 50 个的话，那么对象关联就需要创建 50 个，因此对于直播老师端而言，人数越多，需要维护的关联关系也就越多，同时需要给每个关系发送音视频媒体流。人数越多，宽带压力也随之而来，相关的配置我们在[《02 | Web端基础API学习》](https://juejin.cn/book/7168418382318927880/section/7171376753263247396)中概述了一些，具体消耗的宽带计算方式，我们在后面讲[《11 | 会议优化：WebRTC 通话过程中宽带计算及网络速率优化》](https://juejin.cn/book/7168418382318927880/section/7172208545956364318)中会详细的介绍。



#### 实现流程

​	首先，我们需要一个直播房间，并且进入该房间时需要区分人员身份，那么就需要在进入时传入一个身份标识。

```js
this.formInline.nickname = getParams("nickname");
this.formInline.roomId = getParams("roomId");
this.formInline.userId = getParams("userId");
this.formInline.pub = getParams("pub")? getParams("pub") : 'no';
if(this.formInline.nickname && this.formInline.roomId && this.formInline.userId){
	this.init()// 连接服务器
}
```



**老师 T** **端**作为发布者，在加入房间后就需要发布自己的直播流，此时还没有任何学生和他建立连接。

```js
// ?userId=9999&roomId=10013&nickname=S&pub=pub
initMeetingRoomPc(){
  if(that.formInline.pub === 'pub'){
    this.localStream = await this.getLocalUserMedia()
    //将本地直播流挂到video标签，在自己的页面显示
    this.setDomVideoStream("localdemo01",this.localStream)
  }
}

```

**学生 S 端**进入房间后，首先获取用户列表，获取到用户列表后找到老师，和老师建立`WebRTC`连接。

```js
// userId=1001&roomId=10013&nickname=S-01
const localUid = this.formInline.userId
// 找到当前房间的视频流发布者 即主播
let publisher = 
    this.roomUserList.filter(e => e.userId !== localUid && e.pub === 'pub')
		.map((e,index) =>{ return e.userId })
if(publisher.length >0){ 
  publisher = publisher[0] 
} else{ 
  return; 
}
// 和发布者建立RTC连接 不发送自己视频流
let pcKey = localUid+'-'+publisher
console.log("pcKey", pcKey);//1001-9999  S-1：1001和老师9999  
let pc = RtcPcMaps.get(pcKey)
if(!pc){
    pc = new PeerConnection(that.rtcPcParams)
    RtcPcMaps.set(pcKey,pc)
}
pc.addTransceiver("audio", {direction: "recvonly"});
pc.addTransceiver("video", {direction: "recvonly"});
// 创建offer
let offer = await pc.createOffer();
// 设置offer为本地描述
await pc.setLocalDescription(offer)
// 发送offer给被呼叫端
let params = {"targetUid":publisher, "userId":localUid, "offer":offer}
that.linkSocket.emit("offer", params)
// 监听相关事件 比如老师的应答信令，视频流等等
that.onPcEvent(pc, localUid, publisher)
```



**老师 T 端**，收到学生的关联意向之后，①创建关联关系并保存；②添加监听；③将视频流添加到媒体轨道；④发送应答。

```js
async onRemoteOffer(fromUid, offer){
  const localUid = this.formInline.userId
  let pcKey = localUid+'-'+fromUid
  let pc = new PeerConnection(this.rtcPcParams)
  RtcPcMaps.set(pcKey, pc)
  console.log("老师监听到远端WebRTC意向", pc);
  this.onPcEvent(pc, localUid, fromUid)
  for (const track of this.localStream.getTracks()) {
  	pc.addTrack(track);
  }
  pc.setRemoteDescription(offer)
  let answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  let params = {"targetUid":fromUid, "userId":localUid, "answer":answer}
  this.linkSocket.emit("answer", params)
}
```



​	以上则为直播的基本流程，其他直播场景可对此进行类比。



