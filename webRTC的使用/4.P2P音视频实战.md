#### P2P音频实战

**PC**: 核心对象**PeerConnection**				 **caller:** 呼叫方A					 **callee:** 应答方B

**呼叫端A**

​	**localRtcPc**为本地实例化后的**PeerConnection**实例，与前面整体流程有差异的地方是，我们现在在初始化 `pc` 后，直接同步获取本地摄像头和音频输入并添加到 `pc` 中。初始获取媒体流需要一定时间响应，如果在乎创建连接时间的，这一步可异步完成。

---------

```js
async initCallerInfo(callerId, calleeId) {
  // 初始化PC核心对象
	this.localRtcPC = new PeerConnection();
  // 获取本地媒体并添加到PC对象中
  let localStream = await this.getLocalUserMedia({ audio: true, video: true; });
  for (const track of localStream.getTracks()) {
    this.localRtcPc.addTrack(track);
  }
  // 本地dom渲染
  await this.setDomVideoStream("localdemo01", localStream)
  // 回调监听
  this.onPcEvent(this.localRtcPc,callerId,calleeId)
  // 创建offer
  let offer = await this.localRtcPc.createOffer();
  // 设置offer为本地描述
  await this.localRtcPc.setLocalDescription(offer)
  // 发送offer给被呼叫端
  let params = {"targetUid":calleeId, "userId":callerId, "offer":offer}
  this.linkSocket.emit("offer", params)
}
```

- A 呼叫 B 后双方同意建立通信，A 首先初始化 `pc`，代码中的`localRtcPc `。

- 然后 A 初始化本地`mediaStream`，并添加到 pc 对象中，同时渲染在本地预览 DOM 元素。

- 初始化回调信息，比如 `ontrack`（监听B端媒体），`onicecandidate`（双方 ICE 候选信息）事件等。

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

```js
onPcEvent(pc, localUid, remoteUid) {
	const that = this;
  this.channel = pc.createDataChannel("chat");
  pc.ontrack = function(event) {
    that.setRemoteDomVideoStream("remoteVideo01",event.track)
  };
  pc.onnegotiationneeded = function(e){
    console.log("重新协商",e)
  }
  pc.ondatachannel = function(ev) {
    console.log('Data channel is created!');
  };
  pc.onicecandidate = (event) => {
    if (event.candidate) {
      that.linkSocket.emit('candidate',							   			
      	{'targetUid':remoteUid, "userId":localUid, "candidate":event.candidate })
    } else {
      /* 在此次协商中，没有更多的候选了 */
      console.log("在此次协商中，没有更多的候选了")
    }
  }
}
```

- 创建`offer`信令设置为本地描述后发送给 B 。

- 等 B 创建应答信令之后，信令服务器会将其转发到 A 这边。

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

```js
async onRemoteAnswer(fromUid,answer){
    await this.localRtcPc.setRemoteDescription(answer);
}
```

- A 接受 B 的 `answer`信令后，将其设置为 `remoteDesc `。

![](F:\MyNote\笔记图片\ice候选打印.png)

此处可以看出，**这个过程是贯穿整个会话的，直到`ice`候选完成。**

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**被呼叫端B**

​	被呼叫端与呼叫端类似，主要代码如下：

```js
async initCalleeInfo(localUid,fromUid){
  // 初始化pc
  this.localRtcPc = new PeerConnection()
  // 初始化本地媒体信息
  let localStream = await this.getLocalUserMedia({ audio: true, video: true })
  for (const track of localStream.getTracks()) {
    this.localRtcPc.addTrack(track);
  }
  // dom渲染
  await this.setDomVideoStream("localdemo01",localStream)
  // 监听
  this.onPcEvent(this.localRtcPc,localUid,fromUid)
}
```

- B 接听后同时初始化 pc。

- B 创建本地`mediaStream`，并添加到 pc 对象中，同时渲染在本地预览 Dom 元素---。

- 同 A 初始化回调监听。

---

```js
async onRemoteOffer(fromUid,offer){
  // B接受到A的offer 设置为remote desc
  this.localRtcPc.setRemoteDescription(offer)
  // 创建应答
  let answer = await this.localRtcPc.createAnswer();
  // 设置为local desc
  await this.localRtcPc.setLocalDescription(answer);
  // 并通过信令服务器发送给A
  let params = {"targetUid":fromUid,"userId":getParams("userId"),"answer":answer}
  this.linkSocket.emit("answer",params)
}
```

- 当然此时 A 发送的`offer`信令通过信令服务器转发到 B 这边，B 将其设置为`remoteDesc`后，同时创建`answer`信令。

---

​	至此，所有的会话建立完成，**在双方监听的 pc 核心方法`ontrack`中，就能拿到双方的音频和视频信息了**。