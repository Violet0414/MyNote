#### 类IM实现

​	在点对点通信的初始化流程中存在一个监听方法**onPCEvent()**，其内部有个函数**createDataChannel**，顾名思义，该方法创建了一个通道，该通道就是webRTC中的dataChannel。通过该通道可以实现无服务端P2P文本等富文本信息的双向传输，只要完成了webRTC会话，即使在视频通话过程中云服务器宕机了也没关系，P2P的即时通讯还是可以正常进行的。

​	![](F:\MyNote\笔记图片\P2P的webRTC双向数据传递.gif)

##### **官方描述**

​	**RTCPeerConnection** 的 **createDataChannel()**方法可以创建一个可以发送任意数据的数据通道， 常用于后台传输内容，例如：图像、文件传输、聊天文字等其他数据，当然除了后台，最常用的就是 P2P 中客户端的双向通信了。

**基础语法和使用**

下面的创建 **datachannel** 的前提是双方已经完成**WebRTC**的基础信令交换，**pc**变量为初始化后的**RTCPeerConnection**。

```js
let dataChannel = RTCPeerConnection.createDataChannel(label[, options]);
```

![](F:\MyNote\笔记图片\dataChannel数据传输标准.png)

​	创建一个**dataChannel**，发送并监听消息。

```js
this.channel =  pc.createDataChannel("my channel", {
  protocol: "json",
  ordered: true,
});

-----------------监听消息------------------------------
pc.ondatachannel = function(ev) {
  console.log('Data channel is created!');
  ev.channel.onopen = function() {
    console.log('Data channel ------------open----------------');
  };
  ev.channel.onmessage = function(data) {
    console.log('Data channel ------------msg----------------',data);
  };
  ev.channel.onclose = function() {
    console.log('Data channel ------------close----------------');
  };
};
    
 -------------发送消息--------------------------------------   
 this.channel.send(this.rtcmessage);
```

​	通过该方式浏览器的NetWork是无法监听到的，因此常规的抓包逻辑直接抓Http或是WS协议是无法获取发送的信息的。想要深入了解原理，可以去看看**SCTP协议** ，点击前往[相关协议说明官方文档地址](https://link.juejin.cn/?target=http%3A%2F%2Fwww.watersprings.org%2Fpub%2Fid%2Fdraft-jesup-rtcweb-data-protocol-04.html)。



#### 流程概览

**建立webSocket服务**

```js
const { io } = require("socket.io-client");

init(userId,roomId,nickname){
  const that = this
  this.userInfo = { userId:userId, roomId:roomId, nickname:nickname }
  this.linkSocket = io(this.$serverSocketUrl, {
    reconnectionDelayMax: 10000,
    transports: ["websocket"],
    query: { "userId": userId, "roomId": roomId, "nickname":nickname }
  });
  this.linkSocket.on("connect",(e)=>{
    console.log("server init connect success",that.linkSocket)
  })
  this.linkSocket.on("roomUserList",(e)=>{
    console.log("roomUserList",e)
    that.roomUserList = e					
  })
  this.linkSocket.on("msg",async (e)=>{
    console.log("msg",e)
    if(e['type'] === 'join' || e['type'] === 'leave'){
      setTimeout(()=>{
        let params = {"roomId":getParams('roomId')}
        that.linkSocket.emit('roomUserList',params)
      },1000)
    }
    if(e['type'] === 'call'){ await that.onCall(e) }
    if(e['type'] === 'offer'){ await that.onRemoteOffer(e['data']['userId'],e['data']['offer']) }
    if(e['type'] === 'answer'){ await that.onRemoteAnswer(e['data']['userId'],e['data']['answer']) }
    if(e['type'] === 'candidate'){ that.localRtcPc.addIceCandidate(e.data.candidate) }
  })
  this.linkSocket.on("error",(e)=>{
    console.log("error",e)
  })
},
```



**初始化PeerConnection核心对象**

```js
async initCalleeInfo(localUid,fromUid){
  //初始化pc
  this.localRtcPc = new PeerConnection()
  //初始化本地媒体信息
  let localStream = await this.getLocalUserMedia({ audio: true, video: true })
  for (const track of localStream.getTracks()) {
  this.localRtcPc.addTrack(track);
  }
  // dom渲染
  await this.setDomVideoStream("localdemo01",localStream)
  // 监听
  this.onPcEvent(this.localRtcPc,localUid,fromUid)
}
```



**创建核心对象回调事件的监听并建立信息传输通道**

```js
onPcEvent(pc,localUid,remoteUid){
  const that = this
  // 建立信息传输通道
  this.channel = pc.createDataChannel("chat");
  pc.ontrack = function(event) {
    console.log(event)
    that.setRemoteDomVideoStream("remoteVideo01",event.track)
  };
  pc.onnegotiationneeded = function(e){
    console.log("重新协商",e)
  }
  pc.ondatachannel = function(ev) {
    console.log('Data channel is created!');
    ev.channel.onopen = function() {
      console.log('Data channel ------------open----------------');
    };
    ev.channel.onmessage = function(data) {
      console.log('Data channel ------------msg----------------',data);
      that.formInline.rtcmessageRes = data.data
    };
    ev.channel.onclose = function() {
      console.log('Data channel ------------close----------------');
    };
  };
  pc.onicecandidate = (event) => {
    if (event.candidate) {
      that.linkSocket.emit(
        'candidate', {'targetUid':remoteUid,"userId":localUid,"candidate":event.candidate}
      )
    } else {
      /* 在此次协商中，没有更多的候选了 */
      console.log("在此次协商中，没有更多的候选了")
    }
  }
},
```



**发送信息**

```js
sendMessageUserRtcChannel(){
  if(!this.channel){
    this.$message.error("请先建立webrtc连接")
  }
  this.channel.send(this.formInline.rtcmessage)
  this.formInline.rtcmessage = undefined
}
```


