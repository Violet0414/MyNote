#### 需解决的问题

1. 首先我们需要将远端浏览器进行关联，在建立关联后才有多媒体通信的基础。
2. 关联关系转换到代码层面，意味着双方浏览器必须存在共性，该共性可以理解成一个核心的载体，有了载体就可以维护关联关系。



#### 核心对象 PeerConnection

​	**PeerConnection**可以说是整个**WebRTC**通话的载体，如果没有这个对象，那么后面所有流程都是没法进行的。

​	在不同的浏览器中，**WebRTC**兼容性不一样，虽然前面开篇词提到它的相关 API 已经成为 W3C 的基础标准，但并不是所有的浏览器都满足这些标准的。**WebRTC**最先开始是谷歌体系，那么兼容性而言，谷歌浏览器就是首选。国内很多的浏览器也是基于谷歌内核的，因此**WebRTC**在很大程度上也是兼容的，这里先说几个常用且兼容**WebRTC**的浏览器：Chrome、360、edge、火狐、Safari。

​	为尽可能地兼容不同浏览器，获取到有效的**PeerConnection**对象，我们可以通过如下方式获取：

```js
let PeerConnection = 
    window.RTCPeerConnection ||  window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
```

在获取到有效的核心对象后，则需要使用该对象自身的核心方法驱动其进行工作。

- **addIceCandidate()：**保存 ICE 候选信息，即双方协商信息，持续整个建立通信过程，直到没有更多候选信息。

- **addTrack()：**添加音频或者视频轨道。

- **createAnswer()：**创建应答信令。

- **createDataChannel()：** 创建消息通道，建立`WebRTC`通信之后，就可以` p2p` 的直接发送文本消息，无需中转服务器。

- **createOffer()：** 创建初始信令。

- **setRemoteDescription()：** 保存远端发送给自己的信令。

- **setLocalDescription()：**保存自己端创建的信令。

   

  ​	以上就是`PeerConnection`这个载体核心驱动的主要方法了，除了这些核心方法之外，还有一些**事件监听函数**，这些监听函数用于监听远程发送过来的消息。

  ​	假如 A 和 B 建立连接，如果 A 作为主动方即呼叫端，则需要调用的就是上述**核心方法**去创建建立连接的信息，而 B 则在另一端使用上述**部分核心方法**创建信息再发送给 A，A 则调用**事件监听函数**去保存这些信息。常用的事件监听函数如下：

- **ondatachannel：** 创建`datachannel`后监听回调以及 `p2p`消息监听。

- **ontrack ：**监听远程媒体轨道即远端音视频信息。

- **onicecandidate：** ICE 候选监听。



#### WebRTC会话流程

​	在获取到相应的核心载体后，使用其内部的api方法则可以完成浏览器之间的相互关联。

![](F:\MyNote\笔记图片\WebRTC会话流程.png)

1. 首先 A 呼叫 B，呼叫之前我们一般通过实时通信协议`WebSocket`即可，让对方能收到信息。

2. B 接受应答，A 和 B 均开始初始化`PeerConnection `实例，用来关联 A 和 B 的`SDP`会话信息。

3. A 调用`createOffer`创建信令，同时通过`setLocalDescription`方法在本地实例`PeerConnection`中储存一份（**图中流程①**）。

4. 然后调用信令服务器将 A 的`SDP`转发给 B（**图中流程②**）。

5. B 接收到 A 的`SDP`后调用`setRemoteDescription`，将其储存在初始化好的`PeerConnection`实例中（**图中流程③**）。

6. B 同时调用`createAnswer`创建应答`SDP`，并调用`setLocalDescription`储存在自己本地`PeerConnection`实例中（**图中流程④**）。

7. B 继续将自己创建的应答`SDP`通过服务器转发给 A（**图中流程⑤**）。

8. A 调用`setRemoteDescription`将 B 的`SDP`储存在本地`PeerConnection`实例（**图中流程⑤**）。

9. 在会话的同时，从图中我们可以发现有个`ice candidate`，这个信息就是 ice 候选信息，A 发给 B 的 B 储存，B 发给 A 的 A 储存，直至候选完成。



​	简单概括下，**即呼叫端创建本地信令并进行存储，然后发送给远端应答端，应答端在收到呼叫端信令后将其存储后，生成应答端信令，将其存储进本地后发送应答端信令至呼叫端，呼叫端收到后也将其存储至本地。**

​	完成以上流程后则相当于建立了WebRTC的会话基础，之后可借助该桥梁去添加和监听双方的音视频流信息。